# Стайлгайд

По умолчанию используется airbnb-стайлгайд за некоторыми исключениями.

## Наименование файлов и папок:

- директории и файлы именуются в нотации kebab-case (no exceptions)

## React-компоненты:

- используются только функциональные компоненты (искл. ErrorBoundary),
  объявленные через `const` и типизированные как `FC<Props>`
- используются семантически правильные блоки для компонентов. Не
  используются `<div>` или иные обертки для компонентов, которые состоят из
  одноуровневых блоков.
- добавляется prop `classNames` для стилизации компонента через css-класс
- используются scss-модули для стилей
- используется библиотека `classnames` для комбинации css-классов
- соблюдается порядок импортов
- по возможности не используется inline-css
- функции, константы и объекты, которые не зависят от пропсов, выносятся за
  пределы функции компонента
- обновление стейта всегда производится с учетом предыдущего состояния
- начальное состояние стейт-переменных содержит корректный тип данных
- пропсы описаны через `type`
- не нужно оборачивать хэндлер в `useCallback`, если компонент, в который
  передается данный хэндлер не обернут в HOC memo
- все обработчики, добавленные через `addEventListener`, удаляются при
  размонтировании компонента
- бизнес-логика выносится в кастомные хуки, чтобы не перегружать компонент кодом
- имена пользовательских хуков начинаются с `use`
- для компонента написана документация на русском языке: описание и пропсы
- порядок тестов: рендер и структура компонента, работа пропсов, работа
  обработчиков событий, пользовательские хуки
- в тестах для рендера компонента используется фабрика вместо `beforeEach`
- тесты описаны на русском языке

## TypeScript

- имена переменных, функций и параметров написаны в camelCase
- используется async/await и try/catch вместо Promise.then().catch(), но могут
  быть исключения
- не используется `return await`, за этим следит линтер
- все асинхронные процедуры завершены блоком `catch`, ошибки обработаны
- не игнорируются замечания линтера, необходимость отключения правил обсуждается
  на ревью. Отключение допускается для временных заглушек
- не допускается "типизация" через `any`
- классы типизируются через интерфейсы
- объекты типизируются через `type`
- непубличные методы классов должны иметь ключевое слово, указывающее на его
  скоуп (protected, private)
- методы классов пишутся в следующем порядке: private, protected, public
- в коде не должно быть "магических значений", выносить в константы
- между крупными блоками кода, в т.ч. перед `if`, `switch` оставлять пустую
  строку

## Порядок импортов:

Предпочтительнее использовать абсолютные импорты других модулей/компонентов от
корня, они идут выше относительных. Относительные импорты используются в том же
модуле.

1. Импорт компонентов из 'react'
2. Импорт всех сторонних библиотек.
3. Импорт всех необходимых пользовательских компонентов
4. Импорт собственных и глобальных типов, констант
5. Импорт всех необходимых redux-действий
6. Импорт кастомных хуков
7. Импорт всех необходимых пользовательских утилит
8. Импорт стилей компонента

Пустые строки между импортами не нужны. Не нужно импортировать React.

## Работа с API

На проекте используется flux-архитектура. Компоненты сами не делают запросы к
API, все взаимодействие с бекендом происходит через Redux.

Цепочка вызовов:

- Компонент подписан на какое-то поле в сторе, которое должно меняться при
  вызове API
- Компонент диспатчит action, который вызывает thunk
- thunk вызывает метод API (все запросы пишутся через вспомогательный класс Api)
  и ждет ответа бекенда, затем обрабатывает полученные данные и кладет их в
  store
- store оповещает подписчиков, что такое-то поле изменилось
- Компонент-подписчик получает оповещение, читает новые данные и перерисовывает
  себя

Для управления состоянием загрузки в store используем
поле `process: ProcessEnum`.

Обязательно пишем моки на вызовы API, чтобы можно было собрать фронт автономно.
